


#  Построение двоичного кода натурального числа
# Вход: натуральное число k : 0 \leq k \leq 2^n - 1.
# Выход: битовая шкала B_n.
def B(k: int, n: int) -> list:
    B_n = [None for _ in range(n - 1 + 1)] 
     
    for i in range(n, 1 + -1, -1): 
        B_n[i - 1] = k % 2 #  очередной бит
        k = k // 2 #  оставшееся число
     
    return B_n 


#  Перечисление подмножеств n-элементного множества
# Вход: число n \geq 0 - мощность множества
# Выход: последовательность кодов подмножеств B(i)
def B_all(n: int):
    for i in range(0, 2 ** n - 1 + 1, 1): yield B(i, n) 


# Вход: i - номер подмножества
# Выход: номер изменяемого разряда
def Q(i: int) -> int:
    q = 1; j = i 
    while j % 2 == 0: j = j // 2; q = q + 1 
    return q 


#  Построение бинарного кода Грея n-элементного множества
# Вход: число n \geq 0 - мощность множества
# Выход: последовательность кодов подмножеств B
def Gray(n: int):
    B_n = [None for _ in range(n - 1 + 1)] #  битовая шкала
    for i in range(1, n + 1, 1): B_n[i - 1] = 0  #  инициализация
    yield B_n #  пустое множество
    for i in range(1, 2 ** n - 1 + 1, 1): 
        p = Q(i) #  определение номера элемента
        B_n[p - 1] = 1 - B_n[p - 1] #  добавление или удаление элемента
        yield B_n #  очередное подмножество

